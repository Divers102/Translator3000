# -*- coding: utf-8 -*-
"""
@author: Vladya
"""

import time
import re
from . import (
    url_opener,
    base_url,
    LOGGER
)


class TokenGenerator(object):

    __author__ = "Vladya"
    _tkk_re = re.compile(r"(?<=tkk:\')\d+\.\d+(?=\')")
    LOGGER = LOGGER.getChild("TokenGenerator")

    def __init__(self):

        self.__tkk = None  # Token-time expressed in hours.

    def __update_tkk_from_web(self):
        self.LOGGER.debug("Start updating 'tkk' from web.")
        page = url_opener.open(base_url)
        _data = ""
        while True:
            chunk = page.read((2 ** 20))
            if not chunk:
                break
            _data += chunk
        result = self._tkk_re.search(_data)
        if not result:
            raise Exception("Not find 'tkk' in 'Google Translate' page.")
        self.__tkk = result.group()
        self.LOGGER.debug("'tkk' updated from web.")

    def get_tkk(self, force_update=False):

        self.LOGGER.debug("Request 'tkk'.")

        if force_update or (not self.__tkk):
            if not force_update:
                self.LOGGER.debug("'tkk' not defined. Updating.")
            self.__update_tkk_from_web()

        token_hour = int(self.__tkk.split('.')[0])
        current_hour = int(((time.time() / 60.) / 60.))
        if current_hour != token_hour:
            self.LOGGER.debug("'tkk' time is over. Updating.")
            self.__update_tkk_from_web()

        return self.__tkk

    def generate_final_token(self, text):

        """
        Create a unique code that is normally generated by the browser
        when working in the web version.

        The code below do not have any specific logic.
        Impersonating the browser by simulating the execution
        of obfuscated Google code.

        Deobfuscation is based on the logic implemented by a "ssut"
        in the project "py-googletrans", adapted to specific needs.
        """

        text_bytes = tuple(map(ord, text))
        tkk = self.get_tkk()

        tkk_parts = tuple(map(int, tkk.split('.')))

        code_array = []
        _size = len(text_bytes)
        skip_byte = False

        for counter, current_byte in enumerate(text_bytes):

            if skip_byte:
                skip_byte = False
                continue

            if (counter + 1) < _size:
                next_byte = text_bytes[(counter + 1)]
            else:
                next_byte = None

            if current_byte < 0x80:

                code_array.append(current_byte)

            else:

                if current_byte < 0x800:

                    code_array.append(((current_byte >> 0b110) | 0b11000000))

                else:

                    if (
                        ((current_byte & 0xfc00) == 0xd800) and
                        (next_byte is not None) and
                        ((next_byte & 0xfc00) == 0xdc00)
                    ):

                        current_byte = (
                            0b10000000000000000 + (
                                ((current_byte & 0b1111111111) << 0b1010)
                            ) + (
                                (next_byte & 0b1111111111)
                            )
                        )
                        code_array.append(
                            ((current_byte >> 0b10010) | 0b11110000)
                        )
                        code_array.append(
                            (((current_byte >> 0b1100) & 0b111111) | 0x80)
                        )
                        skip_byte = True

                    else:

                        code_array.append(
                            ((current_byte >> 0b1100) | 0b11100000)
                        )

                    code_array.append(
                        (((current_byte >> 0b110) & 0b111111) | 0b10000000)
                    )

                code_array.append(
                    ((current_byte & 0b111111) | 0b10000000)
                )

        value = tkk_parts[0]
        for counter, modifier in enumerate(code_array):
            value += modifier
            value = self._strange_modifier(value, "+-a^+6")
        value = self._strange_modifier(value, "+-3^+b+-f")
        value ^= tkk_parts[1]

        if value < 0:
            value = ((value & 0x7fffffff) + 0x80000000)

        value %= 1000000
        return "{0}.{1}".format(value, (value ^ tkk_parts[0]))

    @classmethod
    def _strange_modifier(cls, value, text_commands):

        for a, b, c in map(
            lambda x: text_commands[(x * 3):((x * 3) + 3)],
            xrange((len(text_commands) // 3))
        ):

            modifier = int(c, 16)

            if b == '+':
                modifier = cls.rshift_with_pad(value, modifier)
            else:
                modifier = value << modifier

            if a == '+':
                value = ((value + modifier) & 0xffffffff)
            else:
                value ^= modifier

        return value

    @staticmethod
    def rshift_with_pad(a, b):

        """
        Realization of JS '>>>'.
        """

        if not isinstance(a, (int, long)):
            raise TypeError("Only 'int' type supported bit operations.")

        if a < 0:

            a = abs(a)
            if a > 0x7fffffff:
                raise NotImplementedError(
                    "Negative numbers longer than 31 bits are not supported."
                )

            a |= 0x80000000  # 32 bits of negative number.
            a ^= 0x7fffffff  # Invert the last 31 bits.
            a += 1

        return (a >> b)
